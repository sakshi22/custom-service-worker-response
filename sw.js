// Chrome's currently missing some useful cache methods,
// this polyfill adds them.
importScripts('serviceworker-cache-polyfill.js');
const cacheName = 'swcache'

// Hook for install event!
// This only happens once, when the browser sees this
// version of the ServiceWorker for the first time.
self.addEventListener('install', function(event) {
  // We pass a promise to event.waitUntil to signal how 
  // long install takes, and if it failed
  event.waitUntil(
    caches.open(cacheName).then(function(cache) {
      // Adding static resources to cache
      return cache.addAll([
        './',
        'style.css',
        'logging.js'
      ]);
    })
  );
});
const trace = (x, y) => {
  console.log(x);
  return y;
}

//Hook for fetch event which is called everytime an api is hit
// The fetch event happens for the page request with the
// ServiceWorker's scope, and any request made within that
// page

self.addEventListener('fetch', event => {
  //network first strategy used here. 
  //If we want cache first, then try fetching from cache from cache first and if it's not available then hit the network (and cache the response!)
  event.respondWith(navigator.onLine
        ? cacheRequest(event.request)
        : fetchResponseFromCache(event.request)
  )
});

const cacheResponse = (cache, request, response, log) => {
  console.log(log, request.url);
  //cache.put(request, response.clone()); ---- uncomment if we want the actual response to be cached
  // can also be used to encrypt response.data!
  var res = new Response('hello, this is an offline response generated by service worker!!') // manipulate response here
  cache.put(request, res);
  return response;
}

const cacheRequest = request => trace(`+ caching ${request.url}`, 
  caches.open(cacheName).then(cache =>
    fetch(request.clone()).then(response => 
      cacheResponse(cache, request, response, '* cached ')
    )
  )
);

const fetchResponseFromCache = request =>
  caches.open(cacheName).then(cache =>
    cache.match(request).then(resp => {
      //if response is encrypted while caching, decrypt here!
      if(!!resp) {
        console.log('> from cache', request.url)
        return resp;
      } else {
        console.log('! not in cache', request.url)
        return fetch(request).then(response => 
          cacheResponse(cache, request, response, '$ cached ')
        )
      }
    })
  );